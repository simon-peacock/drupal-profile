<?php

/**
 * @file
 * General utility functions module main file.
 */

/**
 * Text trim.
 *
 * Trim text removing HTML markup.
 *
 * @param string $text
 *   Text to be trimmed.
 * @param int $length
 *   Maximum length of the output text.
 * @param string $ellipsis
 *   Adds an ellipsis to trimmed text.
 * @param bool $words
 *   Trim based on words or characters.
 *
 * @return string
 *   Trimmed text.
 */
function ubm_emea_utils_trim_text($text, $length, $ellipsis = FALSE, $words = FALSE) {
  // Strip tags.
  $output = strip_tags(str_replace('<', ' <', $text));

  // Strip out line breaks.
  $output = preg_replace('/\n|\r|\t/m', ' ', $output);

  // Strip out non-breaking spaces.
  $output = str_replace('&nbsp;', ' ', $output);
  $output = str_replace("\xc2\xa0", ' ', $output);

  // Strip out extra spaces.
  $output = trim(preg_replace('/\s\s+/', ' ', $output));

  $trimmed = FALSE;
  if ($words) {
    if ($length < str_word_count($output)) {
      $text_words = preg_split('/\s/', $output, NULL, PREG_SPLIT_NO_EMPTY);
      $output = implode(" ", array_slice($text_words, 0, $length));
      $trimmed = TRUE;
    }
  }
  else {
    if ($length < drupal_strlen($output)) {
      $output = truncate_utf8($output, $length);
      $trimmed = TRUE;
    }
  }

  if ($ellipsis && $trimmed) {
    $output .= ' ' . $ellipsis;
  }

  return $output;
}

/**
 * Process blocks information and store in database.
 */
function ubm_emea_utils_position_blocks($blocks) {
  foreach ($blocks as $block) {
    // Save block position.
    foreach ($block['themes'] as $theme) {

      // Check if block position is already defined.
      $defined = db_select('block')
        ->fields('block', array('bid'))
        ->condition('theme', $theme['theme'])
        ->condition('module', $block['module'])
        ->condition('delta', $block['delta'])
        ->execute()
        ->rowCount();

      if ($defined) {
        db_update('block')
          ->fields(array(
            'status' => $theme['status'],
            'weight' => $theme['weight'],
            'region' => $theme['region'],
            'custom' => $block['custom'],
            'visibility' => $block['visibility'],
            'pages' => $block['pages'],
            'title' => $block['title'],
            'cache' => $block['cache'],
            'css_class' => $block['css_class'],
          ))
          ->condition('theme', $theme['theme'])
          ->condition('module', $block['module'])
          ->condition('delta', $block['delta'])
          ->execute();
      }
      else {
        db_insert('block')
          ->fields(array(
            'module' => $block['module'],
            'delta' => $block['delta'],
            'theme' => $theme['theme'],
            'status' => $theme['status'],
            'weight' => $theme['weight'],
            'region' => $theme['region'],
            'custom' => $block['custom'],
            'visibility' => $block['visibility'],
            'pages' => $block['pages'],
            'title' => $block['title'],
            'cache' => $block['cache'],
            'css_class' => $block['css_class'],
          ))
          ->execute();
      }
    }
  }
}

/**
 * Validate text field as integer.
 */
function ubm_emea_utils_element_validate_text_integer($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    if (!filter_var($element['#value'], FILTER_VALIDATE_INT)) {
      form_error($element, t('%title field sould have a integer value.', array('%title' => $element['#title'])));
    }
  }
}

/**
 * Validate text fields as web link url.
 */
function ubm_emea_utils_element_validate_text_link_url($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    $parsed_url = parse_url($element['#value']);
    if (!$parsed_url) {
      form_error($element, t('%title field is an invalid url.', array('%title' => $element['#title'])));
    }
    elseif (isset($parsed_url['scheme']) && $parsed_url['scheme'] != 'http' && $parsed_url['scheme'] != 'https') {
      form_error($element, t('%title field should have the http or https protocols.', array('%title' => $element['#title'])));
    }
  }
}

/**
 * Validate text field as alphanumeric.
 */
function ubm_emea_utils_element_validate_text_alphanumeric($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    if (!mb_ereg_match('^[[:alnum:] ]*$', $element['#value'])) {
      form_error($element, t('In %title field only letters and numbers are allowed.', array('%title' => $element['#title'])));
    }
  }
}

/**
 * Validate text field as address.
 */
function ubm_emea_utils_element_validate_text_address($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    if (!mb_ereg_match('^[[:alnum:]\,\. ]*$', $element['#value'])) {
      form_error($element, t('In %title field only letters and numbers are allowed.', array('%title' => $element['#title'])));
    }
  }
}

/**
 * Validate text field as alpha.
 */
function ubm_emea_utils_element_validate_text_alpha($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    if (!mb_ereg_match('^[[:alpha:] ]*$', $element['#value'])) {
      form_error($element, t('In %title field only letters are allowed.', array('%title' => $element['#title'])));
    }
  }
}

/**
 * Validate text field as phone number.
 */
function ubm_emea_utils_element_validate_text_phone($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    if (!mb_ereg_match('^\+?[0-9\s]*$', $element['#value'])) {
      form_error($element, t('%title field should have digits white spaces and a initial plus symbol.', array('%title' => $element['#title'])));
    }
  }
}

/**
 * Validate text field as email.
 */
function ubm_emea_utils_element_validate_text_email($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    if (!filter_var($element['#value'], FILTER_VALIDATE_EMAIL)) {
      form_error($element, t('%title field should be a valid email address.', array('%title' => $element['#title'])));
    }
  }
}

/**
 * Enable predefault tracking settings with atom support.
 */
function ubm_emea_utils_enable_default_form_tracking_settings($form_tracking) {
  if (module_exists('ubm_forms_tracking') && module_exists('ubm_atom')) {
    foreach ($form_tracking as $form) {
      $form_tracking_id = db_insert('ubm_forms_tracking')
        ->fields(array(
          'form_type' => $form['form_type'],
          'engine_type' => $form['engine_type'],
          'enabled' => $form['enabled'],
          'mapping' => $form['mapping'],
          'last_processed_id' => $form['last_processed_id'],
        ))
        ->execute();
      db_insert('ubm_entityform_tracking')
        ->fields(array(
          'ftid' => $form_tracking_id,
          'entityform_type' => $form['ubm_entityform_tracking']['entityform_type'],
        ))
        ->execute();
      db_insert('ubm_atom')
        ->fields(array(
          'ftid' => $form_tracking_id,
          'Product_cd' => $form['ubm_atom']['Product_cd'],
        ))
        ->execute();
    }
  }
}

/**
 * Create menus.
 */
function ubm_emea_utils_create_menus($menus) {

  foreach ($menus as $menu) {
    menu_save($menu);
  }

  menu_rebuild();
}

/**
 * Create links.
 */
function ubm_emea_utils_create_menu_links($links) {

  foreach ($links as $link) {
    if (isset($link['parent'])) {
      $parent_route = drupal_get_normal_path($link['parent']);
      $parent_item = ubm_emea_utils_load_menu_link_by_path($link['menu_name'], $parent_route);
      unset($link['parent']);
      if ($parent_item) {
        $link['plid'] = $parent_item->mlid;
      }
    }

    menu_link_save($link);
  }

  menu_rebuild();
}

/**
 * Give access permissions for roles to nodequeues.
 *
 * @param string $nodequeue_name
 *   Nodequeue name.
 * @param array $roles
 *   Array of roles to have permissions.
 */
function ubm_emea_utils_nodequeue_grant_roles($nodequeue_name, array $roles) {

  if (module_exists('nodequeue')) {
    $nodequeue = nodequeue_load_queue_by_name($nodequeue_name);
    foreach ($roles as $role) {
      db_insert('nodequeue_roles')
        ->fields(array(
          'qid' => $nodequeue->qid,
          'rid' => $role->rid,
        ))
        ->execute();
    }
  }

}

/**
 * Grant permissions processing a permissions array.
 */
function ubm_emea_utils_events_permissions_grant($permissions) {
  $roles = array();

  foreach ($permissions as $permission) {
    if (module_exists($permission['module'])) {
      foreach ($permission['roles'] as $role_name) {
        // Load role data.
        if (!isset($roles[$role_name])) {
          $roles[$role_name] = user_role_load_by_name($role_name);
        }

        // Convert vocabulary names to vocabulary ids.
        if (strpos($permission['name'], 'delete terms in ') === 0) {
          $vocab = taxonomy_vocabulary_machine_name_load(substr($permission['name'], 16));
          $permission['name'] = str_replace($vocab->machine_name, $vocab->vid, $permission['name']);
        }
        elseif (strpos($permission['name'], 'edit terms in ') === 0) {
          $vocab = taxonomy_vocabulary_machine_name_load(substr($permission['name'], 14));
          $permission['name'] = str_replace($vocab->machine_name, $vocab->vid, $permission['name']);
        }

        user_role_grant_permissions($roles[$role_name]->rid, array($permission['name']));
      }
    }
  }
}

/**
 * Create taxonomy terms declared in array.
 */
function ubm_emea_utils_events_create_taxonomy_terms($terms) {
  foreach ($terms as $term) {
    $voc = taxonomy_vocabulary_machine_name_load($term['vocabulary']);
    if ($voc) {
      unset($term['vocabulary']);
      $term['vid'] = $voc->vid;
      taxonomy_term_save((object) $term);
    }
  }
}

/**
 * Create pages declared in array.
 */
function ubm_emea_utils_create_pages($pages, $language = 'en') {

  foreach ($pages as $page) {
    $time = time();

    $node = new stdClass();
    $node->type = 'page';

    node_object_prepare($node);

    $node->uid = 1;
    $node->name = 'admin';
    $node->title = $page['title'];
    $node->language = $language;
    $node->body[$language]['0']['value'] = $page['node_body'];
    $node->body[$language]['0']['format'] = 'filtered_html';

    $node->path = array('pathauto' => FALSE, 'alias' => $page['link_path']);
    $node->comment = 0;
    $node->status = 1;
    $node->revision = 0;
    $node->log = 'Programmatically created: ' . date('D, F j, Y');
    $node->changed = $time;
    $node->created = $time;

    node_submit($node);
    node_save($node);

    if ($page['menu_link']) {
      $menu_item = $page['menu_link'];
      $menu_item['link_path'] = 'node/' . $node->nid;
      if (isset($menu_item['parent'])) {
        $parent_route = drupal_get_normal_path($menu_item['parent']);
        $parent_item = ubm_emea_utils_load_menu_link_by_path($menu_item['menu_name'], $parent_route);
        unset($menu_item['parent']);
        if ($parent_item) {
          $menu_item['plid'] = $parent_item->mlid;
        }
      }

      menu_link_save($menu_item);
    }
  }

  menu_cache_clear_all();
}

/**
 * Load a link from a concrete menu by path.
 */
function ubm_emea_utils_load_menu_link_by_path($menu, $path) {
  return db_select('menu_links', 'm')
    ->fields('m')
    ->condition('menu_name', $menu)
    ->condition('link_path', $path)
    ->execute()
    ->fetch();
}

/**
 * Disable views displays.
 */
function ubm_emea_utils_disable_views_displays($views) {
  foreach ($views as $key => $view_name) {
    $view = views_get_view($key);
    if ($view) {
      foreach ($view_name['display'] as $display) {
        if (isset($view->display[$display])) {
          $view->display[$display]->display_options['enabled'] = FALSE;
        }
      }
      views_save_view($view);
    }
  }
}

/**
 * Saves an image style.
 */
function _ubm_emea_utils_save_image_styles($styles) {
  foreach ($styles as $style_key => $style) {
    $created_style = image_style_save(array(
      'name' => $style_key,
      'label' => $style['label'],
    ));
    foreach ($style['effects'] as $effect) {
      $effect['isid'] = $created_style['isid'];
      image_effect_save($effect);
    }
  }
}

/**
 * Generate fields with multilanguage support for feeds default.
 */
function ubm_emea_utils_feeds_generate_i18n_fields(array $translatable_fields) {
  $languages = array_keys(language_list());
  $default_language = language_default('language');

  $feeds_fields = array();

  foreach ($translatable_fields as $translatable_field) {
    foreach ($languages as $language) {
      $translatable_field_settings = array(
        'source' => ($language == $default_language) ? $translatable_field['source'] : $translatable_field['source'] . ' (' . $language . ')',
        'target' => $translatable_field['target'] . ':et:' . $language,
      );
      $feeds_fields[] = array_replace($translatable_field, $translatable_field_settings);
    }
  }

  return $feeds_fields;
}

/**
 * Generate taxonomy terms.
 */
function ubm_emea_utils_create_taxonomy_terms($taxonomy_terms) {
  foreach ($taxonomy_terms as $vocabulary_name => $terms) {
    $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_name);
    _ubm_emea_utils_create_vocabulary_taxonomy_terms($vocabulary->vid, $terms);
  }
}

/**
 * Generate taxonomy terms with hierarchical information.
 */
function _ubm_emea_utils_create_vocabulary_taxonomy_terms($vid, $terms, $parent = NULL) {
  foreach ($terms as $term) {
    $taxonomy_term = new stdClass();
    $taxonomy_term->vid = $vid;
    $taxonomy_term->name = $term['name'];
    $taxonomy_term->language = 'en';
    if (isset($term['weight'])) {
      $taxonomy_term->weight = $term['weight'];
    }
    if (isset($parent)) {
      $taxonomy_term->parent = $parent;
    }
    taxonomy_term_save($taxonomy_term);

    if (isset($term['children'])) {
      _ubm_emea_utils_create_vocabulary_taxonomy_terms($vid, $term['children'], $taxonomy_term->tid);
    }
  }
}

/**
 * Loads a full format object.
 *
 * The drupal api function does not load the format with the filter information.
 */
function ubm_emea_utils_filter_format_load($format_id) {
  $format = filter_format_load($format_id);
  if (empty($format->filters)) {
    // Get the filters used by this format.
    $filters = filter_list_format($format->format);
    // Build the $format->filters array...
    $format->filters = array();
    foreach ($filters as $name => $filter) {
      foreach ($filter as $k => $v) {
        $format->filters[$name][$k] = $v;
      }
    }
  }
  return $format;
}
